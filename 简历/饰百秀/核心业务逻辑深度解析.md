# Special 项目核心业务逻辑深度解析

## 1. 任务操作权限的精确控制逻辑

### 1.1 基于角色和状态的复杂权限判断
```javascript
// myPlan.vue 中的 rowClick 函数 - 核心权限控制逻辑
const rowClick = (record, index) => {
  // 首先检查是否是今天开始的任务
  if (isToDay(record)) {
    submitStartTask(record.id, index)
    return
  }
  
  // 检查是否需要PC端操作的特殊任务
  if (record.is_first == 1 || record.place_order == 1) {
    goPcOpen() // 显示PC操作提示
    return
  }

  // 一级任务权限控制 (level == 1)
  if (record.level == 1) {
    let item = {
      ...state.data,
      ...state.projectInfo,
      taskId: record.task_id,
      type: record.type,
    }
    
    // 审批人 + 进行中状态 -> 可以填写表单
    if (record.approver_id == state.uid && record.state == 0) {
      router.push({ path: `/project-detail/form`, query: item })
    } 
    // 成员 + 待审核状态 -> 可以审核
    else if (record.member_id == state.uid && record.state == 1) {
      router.push({ path: `/project-detail/audit-task`, query: record })
    } 
    // 已完成状态 -> 只能查看
    else if (record.state == 2) {
      router.push({ path: `/project-detail/form`, query: item })
    } 
    else {
      Toast("暂时无法操作!")
    }
    return
  }

  // 二级任务权限控制 (level == 2)
  if (record.level == 2) {
    // 负责人 + 进行中状态 -> 可以填写
    if (record.responsible_id == state.uid && record.state == 0) {
      let item = {
        ...state.data,
        ...state.projectInfo,
        taskId: record.task_id,
        type: record.type,
      }
      router.push({ path: `/project-detail/form`, query: item })
    } 
    // (审批人或成员) + 待审核状态 -> 可以审核
    else if ((record.approver_id == state.uid || record.member_id == state.uid) && record.state == 1) {
      router.push({ path: `/project-detail/audit-task`, query: record })
    } 
    // 已完成状态 -> 只能查看审核页面
    else if (record.state == 2) {
      router.push({ path: `/project-detail/audit-task`, query: record })
    } 
    else {
      Toast("暂时无法操作!")
    }
    return
  }

  // 三级任务权限控制 (level == 3) - 最复杂的权限逻辑
  if (record.level == 3) {
    let item = {
      ...state.data,
      ...state.projectInfo,
      taskId: record.task_id,
      type: record.type,
    }
    
    // 检查是否是订单类型任务
    let order_type = record.order_type == "order" || record.order_type == "customized"
    
    // 执行人 + 进行中状态
    if (record.executor_id == state.uid && record.state == 0) {
      if (!order_type) {
        router.push({ path: `/project-detail/form`, query: item })
      } else {
        goPcOpen() // 订单类型需要PC端操作
      }
    } 
    // 负责人 + 待审核状态
    else if (record.responsible_id == state.uid && record.state == 1) {
      if (!order_type) {
        router.push({ path: `/project-detail/audit-task`, query: record })
      } else {
        goPcOpen() // 订单类型需要PC端操作
      }
    } 
    // 已完成状态的复杂处理
    else if (record.state == 2) {
      if (record.executor_id != state.uid && !order_type) {
        // 非执行人且非订单类型 -> 查看审核页面
        router.push({ path: `/project-detail/audit-task`, query: record })
      } else {
        Toast("暂时无法操作!")
      }
    } 
    else {
      Toast("暂时无法操作!")
    }
  }
}
```

### 1.2 任务开始时间的精确控制
```javascript
// 判断任务是否可以在今天开始
const isToDay = (record) => {
  let name = {
    '3': 'executor_id',    // 三级任务 - 执行人
    '2': 'responsible_id', // 二级任务 - 负责人
    '1': 'approver_id',    // 一级任务 - 审批人
  }
  
  // 三个条件必须同时满足：
  // 1. 任务未开始 (is_start == 0)
  // 2. 当前用户是对应角色的负责人
  // 3. 今天是任务的开始日期
  if(record.is_start == 0 && state.uid == record[name[record.level]]){
    return dateToString(new Date(), 'getDate') == record.start_time ? true : false
  }
  return false
}
```

## 2. 任务状态管理的复杂逻辑

### 2.1 任务状态定义和转换
```javascript
// 任务状态映射
const status = {
  "0": "进行中",     // 任务已开始，正在执行
  "1": "待审核",     // 任务已提交，等待审核
  "2": "已完成",     // 任务审核通过，已完成
  "3": "已延期",     // 任务超过截止时间
}

// 延期任务的识别逻辑
const isEndDate = (item) => {
  let data = ['task-unit']
  // 如果今天是截止日期且任务未完成，标记为警告
  if(item.end_time == moment().format("YYYY-MM-DD") && item.state != '2'){
    data.push('warn')
  }
  return data
}

// 延期任务的显示逻辑
<span :class="item.is_delay == 1 ? 'status delay-task' : 'status'">
  {{ item.is_delay == 1 ? "延期" : "" }}{{ status[item.state] }}
</span>
```

### 2.2 任务提交的验证逻辑
```javascript
// form.vue 中的任务提交验证
const onSubmit = () => {
  let params = {
    project_id: state.data.project_id,
    remarks: formState.remarks || "",
    member_id: formState.memberId
  }
  params[`${state.data.type}_id`] = state.data.taskId
  
  // 验证1: 必须选中任务内容
  if(!formState.status){
    Toast("必须选中任务内容!")
    return false
  }
  
  // 验证2: 所有子任务必须完成
  for(let i in curContent.value){
    if(curContent.value[i].is_checked != true){
      Toast("有未提交的下级任务!")
      return false
    }
  }
  
  // 验证3: 必须上传附件
  if(fileList.value.length == 0) {
    Toast("必须上传附件!")
    return false
  }
  
  // 验证4: 关联上传的文件
  if(formState.img.length > 0) {
    params.img = formState.img.join(",")
  }
  
  // 根据任务类型动态调用对应的提交接口
  let post = dynamicinterface[state.data.type.toString()][1]
  state.loading = true
  post(params).then((res) => {
    if (res.data.code == 1) {
      state.loading = false
      Toast("提交成功!")
      router.go(-1)
    }
  }).catch((err) => {
    state.loading = false
    Toast("获取失败")
    console.log("返回 res=", err)
  })
}
```

### 2.3 任务审核的处理逻辑
```javascript
// auditDrawer.vue 中的审核逻辑
const submit = () => {
  let params = {}
  params[`${state.data.type}_id`] = state.data.task_id
  
  // 验证审核状态必须选择
  if(state.status == undefined){
    Toast("必须选择状态!")
    return
  }
  
  // 设置审核状态: "1"=通过, "0"=驳回
  params.examine_status = state.status
  
  // 根据任务类型动态调用审核接口
  let post = dynamicinterface[state.data.type.toString()][1]
  post(params).then((res) => {
    if (res.data.code == 1) {
      Toast("提交成功")
      router.push({
        path: `/project-detail/my-plan`,
        query: {project_id: state.data.project_id}
      })
    }
  }).catch((err) => {
    Toast('提交失败')
    console.log("返回 res=", err)
  })
}

// 动态接口映射 - 支持四个阶段的审核
const dynamicinterface = {
  proposal: [getSubmitProposaltask, examineProposalTask],
  design: [getSubmitDesigntask, examineDesignTask],
  construction: [getSubmitConstructiontask, examineConstructionTask],
  ensure: [getSubmitEnsureTask, examineEnsureTask]
}
```

## 3. 项目阶段管理的层级逻辑

### 3.1 四阶段任务的状态管理
```javascript
// proposalPlan.vue 中的状态获取逻辑
const getStatus = (data, num) => {
  let levels = {
    "1": "key",        // 一级任务ID
    "2": "secondKey",  // 二级任务ID
    "3": "thirdkey",   // 三级任务ID
  }
  
  let id = data[levels[num]]
  if (!id) return 0
  
  // 从任务数据中查找对应的任务
  let task = tableData.value.filter((item) => {
    return id == item.id
  })[0]
  
  if (task.end_time == null || task.end_time == "") return 0
  
  // 状态判断逻辑
  if (task.status == 4) {
    return 4  // 已完成
  } else if (new Date(task.end_time).getTime() < new Date().getTime()) {
    return 5  // 已延期
  }
}
```

### 3.2 任务层级的动态管理
```javascript
// 添加三级任务行的逻辑
const addRow = (idx) => {
  tasks.value[idx].thirdTaskLen += 1
  tasks.value[idx].secondTaskLen += 1
  
  // 在指定位置插入新的三级任务
  tasks.value.splice(
    idx + 1,
    0,
    Object.assign({}, tasks.value[idx], {
      thirdTaskLen: tasks.value[idx].thirdTaskLen,
      isShowThirdTaskBtnGroup: false,
      hasRowSpan: false,
      isShowExecutorSelect: false,
      isShowApproverSelect: false,
      isShowChargePersonSelect: false,
      isShowThirdTaskDate: false,
      isShowThirdTaskDescTextarea: false,
      thirdTaskNameStr: "",
      thirdTaskName: "",
      executor: undefined,
      approver: undefined,
      chargePerson: undefined,
      date: ["", ""],
      desc: "",
      sign: tasks.value[idx].sign,
      level: 3,  // 标记为三级任务
    })
  )
  
  // 更新相关任务的层级长度
  setThirdTaskLenByKey(tasks.value[idx].sign, tasks.value[idx].thirdTaskLen)
}
```

## 4. 文件管理的安全逻辑

### 4.1 文件上传的完整流程
```javascript
// 文件读取和转换
const afterRead = (file) => {
  const fromData = new FormData()
  // 关键：将移动端的base64数据转换为标准File对象
  fromData.append('file', dataURLtoFileFun(file.content, file.file.name))
  
  saveFile(fromData).then((res) => {
    if(res.data.code == 1){
      file.status = 'done'
      Toast('上传成功')
      // 保存文件ID，用于后续任务关联
      formState.img.push(res.data.id)
    }else{
      file.status = 'failed'
      file.message = '上传失败'
    }
  }).catch((err) => {
    file.status = 'failed'
    file.message = '上传失败'
  })
}

// Base64到File对象的精确转换
export function dataURLtoFileFun(dataurl, filename) {
  const arr = dataurl.split(',')
  const mime = arr[0].match(/:(.*?);/)[1]
  const bstr = atob(arr[1])
  let n = bstr.length
  const u8arr = new Uint8Array(n)
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n)
  }
  return new File([u8arr], filename, { type: mime })
}
```

### 4.2 文件权限和关联逻辑
```javascript
// 文件显示的权限控制
const initFileList = (imgList) => {
  if(imgList.length > 0){
    let fileArray = []
    for(let j in imgList){
      fileArray.push({
        uid: j,
        name: j,
        status: 'done',
        // 文件URL包含基础API路径，确保权限验证
        url: process.env.VUE_APP_BASE_API + imgList[j].path
      })
    }
    fileList.value = [...fileArray]
  }
}

// 文件预览的安全处理
const handlePreview = async (file) => {
  if (!file.url && !file.preview) {
    file.preview = (await getBase64(file.originFileObj))
  }
  state.path = file.url || file.preview
  previewVisible.value = true
}
```

## 5. 数据同步和状态一致性

### 5.1 实时数据更新机制
```javascript
// 任务开始后的状态同步
const submitStartTask = (id, index) => {
  if(tableData.value[index].loading == true) return  // 防止重复提交
  
  tableData.value[index].loading = true
  startTask({id: id}).then((res) => {
    if(res.data.code == 1){
      Toast('操作成功')
      // 关键：立即更新本地状态，保持数据一致性
      tableData.value[index].is_start = 1
    }else{
      Toast('失败')
    }
    tableData.value[index].loading = false
  }).catch((err) => {
    Toast('失败')
    tableData.value[index].loading = false
  })
}
```

### 5.2 路由状态管理
```javascript
// 路由变化时的数据清理和重新加载
onBeforeRouteUpdate((to) => {
  curContent.value = {}
  fileList.value = []
  formState.img = []
  getData(`?${state.data.type}=${to.query.taskId}`)
})
```

## 6. 数据初始化和状态恢复逻辑

### 6.1 任务详情的完整初始化
```javascript
// form.vue 中的 initData 函数 - 复杂的数据初始化逻辑
const initData = () => {
  state.data = router.currentRoute.value.query
  let post = dynamicinterface[state.data.type.toString()][0]

  post(`?${state.data.type}=${state.data.taskId}`).then((res) => {
    if (res.data.code == 1) {
      // 1. 初始化子任务内容
      if(res.data.data["content"].length > 0){
        for(let i in res.data.data["content"]){
          let item = res.data.data["content"][i]
          curContent.value[item.id] = item
        }
      }

      // 2. 初始化文件列表
      if(res.data.data["img_list"].length > 0){
        let fileArray = []
        for(let j in res.data.data["img_list"]){
          fileArray.push({
            uid: j,
            name: j,
            status: 'done',
            url: process.env.VUE_APP_BASE_API + res.data.data["img_list"][j].path
          })
        }
        fileList.value = [...fileArray]
      }

      // 3. 初始化项目基本信息
      state.project_name = res.data.data.project_info.project_name
      state.create_time = moment(res.data.data.start_time).format('MM/DD')
      state.end_time = moment(res.data.data.end_time).format('MM/DD')

      // 4. 初始化审核人信息
      if(res.data.data.second_task_reviewer != null){
        state.nickname = res.data.data.second_task_reviewer.nickname
        state.roleName = res.data.data.second_task_reviewer.role_name
        formState.memberId = res.data.data.second_task_reviewer.member_id
      }

      // 5. 初始化任务层级和状态
      state.level = res.data.data.level
      state.father_task = res.data.data.father_task
      state.task_name = res.data.data.task_name
      state.content = res.data.data.content

      // 6. 关键：状态转换逻辑
      state.status = res.data.data.status != "1" ? true : false
      formState.status = true  // 默认选中任务内容

      // 7. 权限控制：非执行人和非审批人的只读模式
      if(res.data.data.executor_id != state.uid && res.data.data.approver_id != state.uid){
        // 设置为只读模式
      }

      // 8. 初始化备注信息
      formState.remarks = res.data.data.remarks
    }
  }).catch((err) => {
    Toast('获取失败')
    console.log("返回 res=", err)
  })
}
```

### 6.2 动态任务切换逻辑
```javascript
// 任务ID变更时的数据重置和重新加载
const changeId = (id) => {
  // 更新当前任务ID
  state.data.taskId = id

  // 重置所有相关状态
  state.task_name = ''
  state.content = ''
  curContent.value = []
  state.status = true

  // 重新初始化数据
  initData()
}

// 路由变化时的状态清理
onBeforeRouteUpdate((to) => {
  curContent.value = {}
  fileList.value = []
  formState.img = []
  getData(`?${state.data.type}=${to.query.taskId}`)
})
```

## 7. API转发和数据处理机制

### 7.1 Node.js中间层的核心转发逻辑
```javascript
// routes/index.js 中的通用API转发机制
const getData = (url, res) => {
  let funcs = []
  funcs.push(function (lcb) {
    request.get({
      url: url,
      method: "GET",
    }, function (error, response, body) {
      if (!error && response.statusCode == 200) {
        lcb(JSON.parse(body))  // 成功时解析JSON
      } else {
        lcb({code: -1, data: body, msg: "错误"})  // 失败时返回错误
      }
    })
  })

  // 使用async.waterfall处理异步流程
  async.waterfall(funcs, function (msg) {
    if (msg && msg.code != 1) {
      res.json(msg)  // 返回错误信息
    } else {
      res.json(msg)  // 返回成功数据
    }
  })
}

// 通用路由转发 - 支持所有project相关接口
router.get('/project/*', function(req, res, next) {
  getData(url + req.url + getParams(req), res)
})

// 参数拼接函数
let getParams = (req) => {
  let params = ''
  for(let i in req.query){
    params += `${i}=${req.query[i]}`
  }
  return params
}
```

### 7.2 数据库连接池管理
```javascript
// 数据库连接池配置
var sqlAdmin = mysqlNew.createPool(config.updbQuery)

// 统一的数据库查询函数
queryDB = (sql, paramArr, cb) => {
  sqlAdmin.getConnection((err, connection) => {
    if (err) {
      cb({ code: -1, msg: '数据库连接失败！' })
      console.info("err ---- ", err)
      return
    }

    connection.query(sql, paramArr, (err, result) => {
      if (err) {
        connection.release()  // 确保连接释放
        cb({ code: -1, msg: '数据库查询数据失败！' })
        console.info('数据库查询数据失败！', err)
        return
      }

      connection.release()  // 释放连接回池
      cb({ code: 1, data: result })
    })
  })
}
```

## 8. 用户角色和权限的精确映射

### 8.1 角色级别的动态映射
```javascript
// 根据任务级别获取对应的负责人字段
const getRoleField = (level) => {
  let roleMapping = {
    '3': 'executor_id',    // 三级任务 - 执行人负责
    '2': 'responsible_id', // 二级任务 - 负责人负责
    '1': 'approver_id',    // 一级任务 - 审批人负责
  }
  return roleMapping[level]
}

// 根据任务级别获取对应的人员名称字段
const getNameField = (level) => {
  let nameMapping = {
    "1": "approver_id",      // 一级任务显示审批人
    "2": "responsible_name", // 二级任务显示负责人
    "3": "executor_name",    // 三级任务显示执行人
  }
  return nameMapping[level]
}
```

### 8.2 权限验证的多层逻辑
```javascript
// 复合权限验证 - 考虑角色、状态、时间等多个因素
const checkComplexPermission = (task, user, action) => {
  // 1. 基础角色权限检查
  const rolePermission = checkRolePermission(task, user, action)
  if (!rolePermission.allowed) return rolePermission

  // 2. 任务状态权限检查
  const statePermission = checkStatePermission(task, action)
  if (!statePermission.allowed) return statePermission

  // 3. 时间约束检查
  const timePermission = checkTimeConstraint(task)
  if (!timePermission.allowed) return timePermission

  // 4. 特殊任务类型检查
  if (task.is_first == 1 || task.place_order == 1) {
    return { allowed: false, message: '需要PC端操作', requirePC: true }
  }

  return { allowed: true }
}
```

## 9. 实时状态同步和UI更新

### 9.1 乐观更新策略
```javascript
// 任务开始的乐观更新 - 先更新UI，再处理错误
const submitStartTask = (id, index) => {
  if(tableData.value[index].loading == true) return

  // 1. 立即设置加载状态，防止重复点击
  tableData.value[index].loading = true

  startTask({id: id}).then((res) => {
    if(res.data.code == 1){
      Toast('操作成功')
      // 2. 成功时立即更新本地状态
      tableData.value[index].is_start = 1
    }else{
      Toast('失败')
      // 3. 失败时可以考虑回滚状态
    }
    tableData.value[index].loading = false
  }).catch((err) => {
    Toast('失败')
    tableData.value[index].loading = false
    // 4. 网络错误时的状态恢复
  })
}
```

### 9.2 状态一致性保证
```javascript
// 提交成功后的页面跳转和状态清理
const onSubmit = () => {
  // ... 验证逻辑 ...

  state.loading = true
  post(params).then((res) => {
    if (res.data.code == 1) {
      state.loading = false
      Toast("提交成功!")

      // 关键：返回上一页而不是重定向，保持导航栈
      router.go(-1)
    }
  }).catch((err) => {
    state.loading = false
    Toast("获取失败")
  })
}

// 审核成功后的精确导航
const submitAudit = () => {
  // ... 审核逻辑 ...

  post(params).then((res) => {
    if (res.data.code == 1) {
      Toast("提交成功")
      // 精确跳转到我的计划页面，传递项目ID
      router.push({
        path: `/project-detail/my-plan`,
        query: {project_id: state.data.project_id}
      })
    }
  })
}
```

## 10. 错误处理和用户体验优化

### 10.1 分层错误处理
```javascript
// 网络层错误处理
service.interceptors.response.use((response) => {
  return response
}, (error) => {
  // 统一的网络错误提示
  Toast('请求超时或服务器异常，请检查网络或联系管理员！')
  return Promise.reject(error)
})

// 业务层错误处理
const handleBusinessError = (res) => {
  if (res.data.code !== 1) {
    // 根据错误码显示不同的错误信息
    const errorMessages = {
      1001: '用户未登录',
      1002: '参数错误',
      1003: '权限不足',
      1004: '数据不存在'
    }
    Toast(errorMessages[res.data.code] || res.data.msg || '操作失败')
    return false
  }
  return true
}
```

### 10.2 用户体验优化细节
```javascript
// 防抖处理 - 防止用户快速点击
const debounceSubmit = debounce(() => {
  onSubmit()
}, 300)

// 加载状态管理
const setLoadingState = (loading) => {
  state.loading = loading
  // 可以添加全局加载遮罩
  if (loading) {
    showGlobalLoading()
  } else {
    hideGlobalLoading()
  }
}

// 空状态处理
<van-empty
  v-if="!loading && tableData.length == 0"
  class="custom-image"
  :image="require('@/assets/svg/empty.svg')"
  description="暂无数据"
/>
```

这个深度解析揭示了Special项目中最核心的业务逻辑实现细节，包括复杂的权限控制、状态管理、文件处理、数据同步机制、API转发逻辑和用户体验优化。每个功能都有精确的业务规则和边界条件处理，体现了企业级应用的完整性和健壮性。
